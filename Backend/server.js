// Importamos los m√≥dulos necesarios
const express = require("express"); // Framework para crear el servidor y manejar rutas.
const mysql = require("mysql"); // M√≥dulo para conectar a la base de datos MySQL.
const cors = require("cors"); // Permite realizar peticiones desde distintos dominios (CORS).
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken"); // Para generar tokens JWT
const http = require('http');

const path = require('path');

const app = express(); // Inicializamos la aplicaci√≥n de Express.
app.use(cors()); // Habilitamos CORS para permitir el acceso desde otros or√≠genes.
app.use(express.json()); // Permite procesar datos en formato JSON que llegan en las solicitudes.

const dotenv = require('dotenv');
dotenv.config();


const port = process.env.PORT || 0;

// üîå Configuraci√≥n de la base de datos MySQL
const db = mysql.createConnection({
  host: "localhost", // Direcci√≥n del servidor de la base de datos (local en este caso).
  user: "root", // Usuario de la base de datos.
  password: "", // Contrase√±a del usuario.
  database: "inventario" // Nombre de la base de datos a utilizar.
});

// Establecemos la conexi√≥n con la base de datos.
db.connect(err => {
  if (err) throw err; // Si hay un error, se muestra y se detiene el proceso.
  console.log("‚úÖ Conectado a la base de datos"); // Mensaje de confirmaci√≥n en consola.
});

// üß† Funci√≥n gen√©rica para rutas GET din√°micas con filtros
function createFilteredGetRoute(table, idField) {

  // Ruta GET para obtener todos los registros de una tabla con opci√≥n de filtro din√°mico
  app.get(`/${table}`, (req, res) => {
    let query = `SELECT * FROM ${table}`; // Base de la consulta SQL
    const values = []; // Array para almacenar los valores de los filtros.

    const searchParams = Object.keys(req.query); // Obtiene los par√°metros de b√∫squeda de la URL.
    if (searchParams.length > 0) { // Verifica si hay filtros en la petici√≥n.
      //BASICAMENTE ESTO ES LO SIGUIENTE, SI YO LE PASOUNA URL ASI http://localhost:3000/categories?name=Electr√≥nica&description=Dispositivos
      //me va a pillar los campos y me  los va a meter en una array diferente sin tocarme la url
      //
      const conditions = searchParams.map(key => {
        
        values.push(`%${req.query[key]}%`); // Escapa y agrega el valor al array.
        return `${key} LIKE ?`; // Agrega la condici√≥n LIKE para el filtro.
      });
      query += " WHERE " + conditions.join(" AND "); // Construimos las condiciones en la consulta SQL.
    }

    // Ejecutamos la consulta en la base de datos.
    db.query(query, values, (err, results) => {
      console.log(query);
      if (err) return res.status(500).send("Error en la consulta a la base de datos."); // Manejo de errores.
      res.json(results); // Respondemos con los resultados obtenidos.
    });
  });

  // Ruta GET para obtener un registro espec√≠fico por su ID
  app.get(`/${table}/:id`, (req, res) => {
    db.query(`SELECT * FROM ${table} WHERE ${idField} = ?`, [req.params.id], (err, result) => {
      if (err) return res.status(500).send(err); // Manejo de errores en la consulta.
      res.json(result[0]); // Respondemos con el primer resultado obtenido.
    });
  });
  // Ruta POST para insertar un nuevo registro en la tabla
  app.post(`/${table}`, (req, res) => {
    console.log("xivato1");
    db.query(`INSERT INTO ${table} SET ?`, req.body, (err, result) => {
      if (err) return res.status(500).send(err); // Manejo de errores al insertar.
      res.json({ id: result.insertId }); // Respondemos con el ID del registro insertado.
    });
  });

  // Ruta PUT para actualizar un registro existente por su ID
  app.put(`/${table}/:id`, (req, res) => {
    db.query(`UPDATE ${table} SET ? WHERE ${idField} = ?`, [req.body, req.params.id], err => {
      if (err) return res.status(500).send(err); // Manejo de errores al actualizar.
      res.sendStatus(200); // Enviamos un estado de √©xito sin contenido.
    });
  });

  // Ruta DELETE para eliminar un registro por su ID
  app.delete(`/${table}/:id`, (req, res) => {
    db.query(`DELETE FROM ${table} WHERE ${idField} = ?`, [req.params.id], err => {
      if (err) return res.status(500).send(err); // Manejo de errores al eliminar.
      res.sendStatus(200); // Enviamos un estado de √©xito sin contenido.
    });
  });
}

// üß© Tablas y sus claves primarias para la generaci√≥n din√°mica de rutas
const tablas = [
  { nombre: "articles", clave: "id" },
  { nombre: "categories", clave: "idCategory" },
  { nombre: "departamentos", clave: "idDepartamento" },
  { nombre: "proyectos", clave: "idProyecto" },
  { nombre: "roles", clave: "idRol" },
  { nombre: "types", clave: "idType" },
  { nombre: "ubicaciones", clave: "id" },
  { nombre: "usuarios", clave: "id" },
  { nombre: "viewmovements", clave: "id" }
];

// üîÑ Creaci√≥n de todas las rutas din√°micamente
tablas.forEach(t => createFilteredGetRoute(t.nombre, t.clave));


// Ruta POST para insertar un nuevo art√≠culo y generar su movimiento de entrada
app.post("/articles-add", (req, res) => {
  console.log("üìå Insertando nuevo art√≠culo...");
  
  db.query("INSERT INTO articles SET ?", req.body, (err, result) => {
    if (err) return res.status(500).send(err); // üö® Manejo de errores
    
    const newArticleId = result.insertId; // üî• Obtiene el ID del art√≠culo reci√©n insertado

    // üìå Crear el movimiento de entrada autom√°tico
    const movementData = {
      idArticle: newArticleId,
      entryDate: new Date(), // üóì Fecha actual
      stock: req.body.stock, // üî¢ Stock inicial
      quantityEntry: req.body.stock, // üî¢ Cantidad ingresada
      location: req.body.location || "Sin ubicaci√≥n", // üìç Ubicaci√≥n opcional
      material: req.body.material || "No especificado",
      model: req.body.modelo || "Desconocido"
    };

    db.query("INSERT INTO viewmovements SET ?", movementData, (err) => {
      if (err) return res.status(500).send(err); // üö® Manejo de errores
      
      console.log("‚úÖ Movimiento de entrada registrado");
      res.json({ id: newArticleId, message: "Art√≠culo a√±adido y movimiento registrado correctamente" });
    });
  });
});



// Ruta POST para registrar usuarios con contrase√±as encriptadas

app.post("/registro", async (req, res) => {
  const { nombre, apellidos, email, contrasenya,idRol,idDepartamento } = req.body;

  console.log("Datos recibidos:", req.body);

  if (!nombre || !apellidos || !email || !contrasenya) {
    console.error("Faltan campos obligatorios");
    return res.status(400).send("Todos los campos son obligatorios");
  }

  try {
    console.log("Iniciando el hash de la contrase√±a...");
    const hashedPassword = await bcrypt.hash(contrasenya, 10);
    console.log("Hash generado:", hashedPassword);

    const query =
      "INSERT INTO usuarios (nombre, apellidos, email, contrasenya, idRol,idDepartamento) VALUES (?, ?, ?, ?, ?,?)";

      console.log(query, [nombre, apellidos, email, hashedPassword,idRol,idDepartamento]);

    db.query(query, [nombre, apellidos, email, hashedPassword,idRol,idDepartamento], (err, result) => {
      if (err) {
        console.error("Error en la base de datos:", err);
        return res.status(500).send("Error en el servidor");
      }

      console.log("Usuario registrado correctamente:", result);
      res.status(200).json({ message: "Usuario registrado correctamente" });
    });
  } catch (error) {
    console.error("Error encriptando la contrase√±a:", error);
    res.status(500).send("Error en el servidor");
  }
});

// Ruta POST para login con autenticaci√≥n JWT
app.post("/login", (req, res) => {
  console.log("Datos recibidos:", req.body);
  const { usuario, pass } = req.body; // Capturamos los datos enviados.
  console.log(req.body.username);
  console.log(req.body.password);
  db.query("SELECT id, idRol, contrasenya FROM usuarios WHERE email = ?", req.body.username, async (err, result) => {
    console.log("aqui");
    if (err) {
      console.error("Error en la consulta SQL:", err);
      return res.status(500).send("Error en el servidor");
    }

    console.log("SELECT id, idRol, contrasenya FROM usuarios WHERE email = ?", req.body.username);
    if (result.length === 0) {
      console.log("Usuario no encontrado");
      return res.status(401).json({ error: "Usuario o contrase√±a incorrectos" });
    }

    const user = result[0];
    console.log("Resultado de la consulta:", user);

    if (!user.contrasenya) {
      console.error("El campo contrasenya est√° vac√≠o o es nulo");
      return res.status(500).send("Error en el servidor");
    }

    console.log(String(user.contrasenya));
    console.log(String(req.body.password));
    const isMatch = await bcrypt.compare(String(req.body.password), String(user.contrasenya)); // Comparamos la contrase√±a ingresada con la encriptada.
    if (!isMatch) {
      console.log("Contrase√±a incorrecta");
      return res.status(401).json({ error: "Usuario o contrase√±a incorrectos" });
    }
    const token = jwt.sign({ id: user.id, IdRol: user.idRol }, "foriestanis", { expiresIn: "15m" });
    console.log(token,user.id, user.idRol);

    res.json({ token,id: user.id, idRol: user.idRol });
  });
});

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

// REVISI√ìN DE CAMPOS OCULTOS DEPENDIENDO DEL TIPO!!!!!!

// Endpoint para obtener los tipos de art√≠culos y sus caracter√≠sticas
// Endpoint para obtener los tipos de art√≠culos y sus caracter√≠sticas
app.get('/api/tipos-articulos', (req, res) => {
  // Realizamos una consulta a la tabla 'tipos_articulos'
  db.query('SELECT * FROM types', (err, tiposResult) => {
    if (err) {
      console.error("Error al obtener tipos de art√≠culos:", err);
      return res.status(500).send('Error al obtener tipos de art√≠culos.');
    }

    // Verificamos si la consulta a tipos_articulos devuelve resultados
    console.log('Tipos de art√≠culos:', tiposResult);

    const tipos = tiposResult.map((tipo) => {
      // Aseg√∫rate de que 'tipo.id' sea un valor v√°lido
      console.log('Tipo de art√≠culo:', tipo);  // Imprimimos el tipo completo para verificar el id

      return new Promise((resolve, reject) => {
        db.query(
          'SELECT nombre FROM caracteristicas WHERE tipo_articulo_id = ?',
          [tipo.idType],  // Aseg√∫rate de usar tipo.id correctamente
          (err, caracteristicasResult) => {
            if (err) return reject(err);
            console.log('Caracter√≠sticas para el tipo:', tipo.nombre, caracteristicasResult);
            resolve({
              tipo: tipo.nombre,
              caracteristicas: caracteristicasResult
            });
          }
        );
      });
    });

    Promise.all(tipos)
      .then((result) => {
        res.json(result);  // Devolvemos el resultado al frontend
      })
      .catch((err) => {
        console.error("Error al obtener caracter√≠sticas:", err);
        res.status(500).send('Error al obtener caracter√≠sticas.');
      });
  });
});

app.use('/assets', express.static(path.join(__dirname, 'assets')));


app.use(express.static(path.join(__dirname, "..", "dist", "inventario", "browser")));

// Redirigir todas las rutas a `index.html`
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, "..", "dist", "inventario", "browser", "index.html"));
});

// Si tienes alguna carpeta de 'assets', puedes configurarla as√≠

// Crear el servidor HTTP
const server = http.createServer(app);

// Escuchar en un puerto din√°mico (0 dejar√° que el sistema seleccione uno)
server.listen(3002, '0.0.0.0', () => {
  const address = server.address();
  console.log(`Servidor Express corriendo en http://0.0.0.0:${address.port}`);
});